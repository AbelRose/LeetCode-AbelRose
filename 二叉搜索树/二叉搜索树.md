### 二叉搜索树(BST)

![img](二叉搜索树.assets/bst_example-a1.png)

- 每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。

- 对于二叉搜索树，我们可以通过***中序遍历*** 得到一个***递增的*** 有序序列。因此，中序遍历是二叉搜索树中最常用的遍历方法。

- 验证:

  ```java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */
  class Solution {
      List<Integer> res = new ArrayList<>();
      public boolean isValidBST(TreeNode root) {
          // In-Order traversal and judge if not the ascending array
          if (root == null) return true;
          inOrder(root);
          for (int i = 1; i < res.size(); i++) {
              if (res.get(i) <= res.get(i-1)) return false;
          }
          return true;
      }
  
      public void inOrder(TreeNode root) {
          if (root != null) {
              inOrder(root.left);
              res.add(root.val); // 中序遍历后的值放到数组里面
              inOrder(root.right);
          }
      }
  }
  ```

- 在计算机程序设计中，迭代器是使程序员能够遍历容器的对象。这是维基百科对迭代器的定义。当前，实现迭代器的最简单的方法是在类似数组的容器接口上。如果我们有一个数组，则我们只需要***一个指针***或者***索引***，就可以轻松的实现函数 next() 和 hasNext()。判断hasNext()的时候可以看索引是否大于结果集的长度即可。


- 在二叉搜索树中实现***搜索***

  根据BST的特性，对于每个节点：

  1. 如果目标值***等于***节点的值，则***返回***节点；
  2. 如果目标值***小于***节点的值，则继续在***左子树***中搜索；
  3. 如果目标值***大于***节点的值，则继续在***右子树***中搜索。

- 在二叉搜索树中实现***插入***

  为目标节点找出合适的叶节点位置，然后将该节点作为叶节点插入。

  1. 根据节点值与目标节点值的关系，搜索左子树或右子树；
  2. 重复步骤 1 直到到达外部节点；
  3. 根据节点的值与目标节点的值的关系，将新节点添加为其左侧或右侧的子节点。

- 在二叉搜索树中实现***删除***

  1. 如果目标节点没有子节点，我们可以直接移除该目标节点。
  2. 如果目标节只有一个子节点，我们可以用其子节点作为替换。
  3. 如果目标节点有两个子节点，我们需要用其中序后继节点或者前驱节点来替换，再删除该目标节点。

  后继结点: 

  Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。

  ```java
  public int successor(TreeNode root) {
      root = root.right;
      while (root.left != null) root = root.left;
      return root;
  }
  ```

  前驱结点: 

  Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。

  ```java
  public int predecessor(TreeNode root) {
      root = root.left;
      while (root.right != null) root = root.right;
      return root;
  }
  ```

  ![在这里插入图片描述](二叉搜索树.assets/309271bd1f94c57fd4e19f5eee624dd2ad3ef8e4d5a3b6eca5556e9f2e43a3bc-file_1576477912310)

  删除的三种情况:

  - 删除的是叶子结点---直接删除

  - 删除的结点不是叶子节点且***拥有右节点***，则该节点可以由该节点的***后继节点进行替代***，该后继节点位于右子树中较低的位置。

  - 删除的节点不是叶子节点且***拥有左节点***。则该节点可以由该节点的***前驱节点进行替代***，该前驱结点位于左子树中较低的位置。

    