# 队列和栈

### 队列

##### 1.实现队列 

可以使用***动态数组***和指向队列***头部***的索引

代码	

```java
// "static void main" must be defined in a public class.

class MyQueue {
    // store elements
    private List<Integer> data;         
    // a pointer to indicate the start position
    private int p_start;            
    public MyQueue() {
        data = new ArrayList<Integer>();
        p_start = 0;
    }
    /** Insert an element into the queue. Return true if the operation is successful. */
    public boolean enQueue(int x) {
        data.add(x);
        return true;
    };    
    /** Delete an element from the queue. Return true if the operation is successful. */
    public boolean deQueue() {
        if (isEmpty() == true) {
            return false;
        }
        p_start++;
        return true;
    }
    /** Get the front item from the queue. */
    public int Front() {
        return data.get(p_start);
    }
    /** Checks whether the queue is empty or not. */
    public boolean isEmpty() {
        return p_start >= data.size();
    }     
};

public class Main {
    public static void main(String[] args) {
        MyQueue q = new MyQueue();
        q.enQueue(5);
        q.enQueue(3);
        if (q.isEmpty() == false) {
            System.out.println(q.Front());
        }
        q.deQueue();
        if (q.isEmpty() == false) {
            System.out.println(q.Front());
        }
        q.deQueue();
        if (q.isEmpty() == false) {
            System.out.println(q.Front());
        }
    }
}
```

缺点: 浪费空间



##### 2.循环队列

队列***空***还是***满***的状态

代码

```java
class MyCircularQueue {
    /**
     * 如果判断完可以添加元素，那么就要移动rear，如果rear到底了，直接让rear指向0位置；否则直接加一。
     * 删除元素时，front同理。最主要的是要维护好size这个变量。
     */
    private int[] arr;
    private int size; // 多用一个size变量就可以实现 头指针front和尾指针rear的解耦
    private int front;
    private int rear; // 要插入的位置 即队尾元素的下一个位置

    /** Initialize your data structure here. Set the size of the queue to be k. */
    public MyCircularQueue(int k) {
        this.arr = new int[k]; 
        this.size = 0; 
        this.front = 0;
        this.rear = 0;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    public boolean enQueue(int value) {
        if(size == arr.length){ // 注意不是arr.length-1 如果是-1的话还是可以加入的
            return false;
        }
        arr[rear] = value;
        size ++;
        rear = rear == arr.length-1 ? 0 : rear + 1;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    public boolean deQueue() {
        if(size == 0){
            return false;
        }
        front = front == arr.length-1 ? 0 : front + 1;
        size --;
        return true;
    }
    
    /** Get the front item from the queue. */
    public int Front() {
        if(size == 0){
            return -1;
        }
        return arr[front];
    }
    
    /** Get the last item from the queue.
    * 获取的是最后一个元素 不是尾指针	
    */
    public int Rear() {
        if(size == 0){
            return -1;
        }
        //=================//
        //return arr[rear];//
        return rear = rear == 0 ? arr[arr.length - 1] : arr[rear-1];

    }
    
    /** Checks whether the circular queue is empty or not. */
    public boolean isEmpty() {
        return size == 0;
    }
    
    /** Checks whether the circular queue is full or not. */
    public boolean isFull() {
        return size == arr.length; 
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
```





























